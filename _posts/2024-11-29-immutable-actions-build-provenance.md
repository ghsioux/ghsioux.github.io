---
layout: post
title: Securing Actions workflows with Immutable Actions
description: A deep dive into the power of immutable actions, wildcard versioning, and build provenance using artifact attestations in GitHub Actions.
comments: false
tags: actions devsecops immutable-actions wildcard-versioning build-provenance artifact-attestations security supply-chain
minute: 25
---

**Long time no see!**  
I've been honing my skills in the AI hills of the DevSecOps realm üèîÔ∏è. Now, I'm back stronger, armed with fresh **quests** to share ‚Äî I hope you've been practicing too. 

Last time, one of my clients was concerned about immutable actions potentially breaking their Actions workflows. They wanted to know if referenced versions would still resolve properly with semantic versioning. The short answer? **All good** ‚Äî and that's thanks to **wildcard versioning**. 

But before we dive into that, let‚Äôs take a step back. What exactly is an immutable action? Why should you even care about it? And what role do artifact attestations play in all of this?

Alright, ninja, let's resume the journey ü•∑.

## 1. Show Me Your Artifacts, I'll Show You Your Build

Artifact attestations in GitHub are used to provide proof of the **integrity** and **origin** of artifacts generated by GitHub Actions workflows. They allow users to verify that the artifacts have not been tampered with and originate from a trusted source (GitHub). They work by generating cryptographically signed metadata that includes information about the artifact, such as the exact commit it was built from, the build environment, and other relevant details.

The integrity is proven by the **cryptographic signatures** included in the attestation. These signatures ensure that the artifact has not been tampered with since it was created. By verifying the signature, users can confirm that the artifact is exactly as it was when it was built. GitHub uses [Sigstore](https://sigstore.dev/docs/) for cryptographic signing of artifacts attestations.

The provenance is proven by the **detailed metadata** included in the attestation, such as the specific commit from which the artifact was built, the GitHub Actions workflow used, and the build environment. This metadata allows users to trace the artifact back to its original source, ensuring it was built from the intended source code in a secure and controlled environment. GitHub uses the Provenance feature from the [OpenSSF's SLSA (Supply chain Levels for Software Artifacts) framework](https://slsa.dev/) to provide this information.

|                           | **With Cryptographic Signature**                                | **Without Cryptographic Signature**                             |
|---------------------------|-----------------------------------------------|---------------------------------------------|
| **With Metadata**            | üü¢ **Secure**<br>- Full traceability.<br>- Artifact integrity assured.<br>- Minimal risk (provided implementation is correct). | üü° **Partial Security**<br>- Traceability provided.<br>- Artifacts may be tampered post-build.<br>- Distribution attacks possible (e.g. artifact substitution). |
| **Without Metadata**           | üü° **Partial Security**<br>- Artifact integrity assured.<br>- No build traceability.<br>- Reproducibility of builds is lost.<br>- Builds could originate from unverified sources. | üî¥ **Insecure**<br>- No traceability or integrity assurance.<br>- High risk of malicious artifacts and insecure builds. |

In the context of modern software development, supply chain security is crucial. Attackers often target the software supply chain as an entry point to compromise systems and data. Artifact attestations add an essential layer of defense by guaranteeing the authenticity and traceability of artifacts from their source to their deployment. This transparency reduces the risk of distributing tampered, malicious, or otherwise compromised software. By securing both integrity and provenance, artifact attestations help organizations ensure that the software running in production is exactly what was intended, offering confidence that build processes are secure and trustworthy.

## 2. Immutable Actions: Securing Workflows at the Source

Well, we now know about the concept of Artifacts Attestations. What if we extend these concepts to **GitHub Actions** themselves? Just like with build artifacts, can we apply **artifact attestations** and certify **build provenance** to actions to ensure that the actions used in our CI/CD pipelines are trustworthy and secure? 

Good news ninja, the answer is yes and this is the very purpose of Immutable Actions. 

Immutable Actions in GitHub provide a more secure and trusted way of publishing and consuming actions. Here are the key aspects:

- **Secure Publishing Flow**: Immutable actions can only be published using an Actions token as part of a workflow run, ensuring that the package is immutably linked to its source repository.
- **Package and Tag Immutability**: Once published, the tags and packages cannot be overwritten or reused, ensuring that the action version remains unchanged.
- **Locking Down Actions Resolution**: Actions are resolved using strict semantic versioning and partial wildcard reference, preventing the use of mutable references like branches or tags.

Under the hood, Immutable Actions achieve this by storing actions as packages in the GitHub Container Registry (ghcr.io) and applying artifact attestations to these packages using the [@actions/attest](https://github.com/actions/toolkit/tree/main/packages/attest) package.

$$
\text{Actions packaging} + \text{Artifact Attestations} = \text{Immutable Actions}
$$

Immutable Actions are a game changer because they significantly enhance the security and reliability of CI/CD pipelines. By ensuring that action versions are immutable and linked to their source repositories, developers can trust that the actions they use have not been tampered with and reflect the exact code and workflow that was originally published.

## 3. A Note on Partial Wildcard Versioning

In GitHub Actions, wildcard versioning is a mechanism that allows you to automatically resolve non-strict semantic versioning references to the latest compatible version within a given range. This approach helps keep your workflows up to date by resolving to the most recent versions that match your specified criteria.

Here's an example of how you can use wildcard versioning in your workflows:

```
 # Note: my-org/my-action refers to a package here, not a repository!
 uses: my-org/my-action@1.0.0   # strict semver
 uses: my-org/my-action@1.x     # latest version with major version 1
 uses: my-org/my-action@1.1.x   # latest version with major & minor version 1
```

When using Immutable Actions (IA), the flexibility of wildcard versioning poses challenges. IA is designed to ensure that an action‚Äôs content and behavior remain constant over time. However, wildcard versioning, like v4.* or v4, resolves to the latest version within that range, such as from v4.1 to v4.2. This dynamic nature could lead to behavior changes, which contradicts the immutability principle.

That said, wildcard versioning still limits changes to a known, compatible set of releases, such as patch or minor updates, making it more stable than fully unrestricted tagging.

In short, while v4 or v4.* tags allow updates within a controlled range, they are still more secure than unpredictable version resolutions. For full immutability, pinning to a specific version (e.g., v4.2.1) is best to ensure stability and avoid unexpected changes.

graph TD
    B[v4.*] -- resolves to --> C[Latest v4.x Version Available]
    C -- chosen --> D[v4.5.1]
    C -.-> K[v4.5.0] 
    E[v4.2.*]
    E -- resolves to --> F[Latest v4.2.x Version Available]
    F -- chosen --> G[v4.2.3]
    F -.-> H[v4.2.2]
    F -.-> I[v4.2.1]


## 4 - Practical Example


## 5 - Next steps


Gassh≈ç üôè